// nodemailer
// const sendOTPVerificationEmail = async (req, res) => {
//   try {

//     const otp = `${Math.floor(1000 + Math.random() * 9000)}`;
//     const duration = "  14 minutes";
//     const message = "Enter This OTP to Continue";
//     const mailOptions = {
//       from: 'techboompage@gmail.com',
//       to: 'anasmuhammed444@gmail.com',
//       subject: 'verify your email',
//       text: otp,
//       html: `<p>${message}</p> <p style="color: tomato; font-size: 25px; letter-spacing: 2px;"><b>${otp}</b></p><p>This Code <b>expires in ${duration} minutes(s)</b>.</p>`,
//     };
//     console.log('Generated OTP', otp);
//     transporter.sendMail(mailOptions, (error, info) => {
//       if (error) {
//         console.error('Error sending email:', error);
//         res.status(500).json({ error: 'Error sending email' });
//       } else {
//         console.log('Email sent successfully:', info.response);
//         res.status(200).json({ message: 'Email sent successfully' });
//       }
//     });
//   } catch (error) {
//     res.status(500).json({ error: error.message });
//   }
// };














// document.addEventListener("DOMContentLoaded", () => {
//   const decreaseButtons = document.querySelectorAll(".decrease-quantity");
//   const increaseButtons = document.querySelectorAll(".increase-quantity");

//   // Function to update total amount
//   function updateTotalAmount() {
//     let totalAmount = 0;

//     // Get all product rows
//     const productRows = document.querySelectorAll(".row.gy-3.mb-4");
//     productRows.forEach((row) => {
//       const productId = row
//         .querySelector(".decrease-quantity")
//         .getAttribute("data-product-id");
//       const quantityInput = row.querySelector(`#count_${productId}`);
//       const quantity = parseInt(
//         row.querySelector(`#count_${productId}`).value,
//         10
//       );
//       const productAmount = parseFloat(
//         row.querySelector(`#productAmount_${productId}`).textContent
//       );

//       totalAmount += productAmount;
//     });


//     // Update the total amount in the HTML
//     const totalAmountCell = document.getElementById("totalAmountCell");
//     const subTotal = document.getElementById("sub-total");
//     totalAmountCell.value = `${totalAmount.toFixed(2)}`;
//     subTotal.textContent = `Rs ${totalAmount.toFixed(2)}`;
//     const hiddenTotalAmount = document.getElementById('hiddenTotalAmount');
//     hiddenTotalAmount.value = totalAmount.toFixed(2);
//   }

//   // Function to send AJAX request to update quantity
//   async function updateQuantity(productId, change) {
//     try {
//       const response = await fetch("/updateQuantity", {
//         method: "POST",
//         headers: {
//           "Content-Type": "application/json",
//         },
//         body: JSON.stringify({ productId, change }),
//       });

//       if (response.ok) {
//         const data = await response.json();
//         console.log("Received new quantity from server:", data.newQuantity);

//         const quantityInput = document.getElementById(`count_${productId}`);
//         const productAmount = document.getElementById(
//           `productAmount_${productId}`
//         );
//         const existingValue = productAmount.getAttribute("data-value");

//         if (quantityInput) {
//           quantityInput.value = data.newQuantity;
//           productAmount.textContent = existingValue * data.newQuantity;

//           // Calculate and update the total amount
//           updateTotalAmount();
//         }
//       } else {
//         console.error("Error updating quantity:", response.statusText);
//       }
//     } catch (error) {
//       console.error("Error updating quantity:", error);
//     }
//   }

//   // Add event listeners to decrease buttons
//   decreaseButtons.forEach((button) => {
//     button.addEventListener("click", () => {
//       const productId = button.getAttribute("data-product-id");
//       const quantityInput = document.getElementById(`count_${productId}`);
//       const quantity = parseInt(quantityInput.value, 10);
//       const availableQuantity = parseInt(quantityInput.getAttribute("data-available-quantity"), 10);

//       if (quantity === 1) {
//         // Prevent further decrease when quantity is 1
//         return;
//       }
//       if (quantity <= availableQuantity) {
//         const outOfStockMessage = document.querySelector(`#outOfStockMessage_${productId}`);
//         outOfStockMessage.style.display = "none";
//       }
//       updateQuantity(productId, -1);
//     });
//   });

//   increaseButtons.forEach((button) => {
//     button.addEventListener("click", () => {
//       // console.log("increase buttons clicked");
//       const productId = button.getAttribute("data-product-id");
//       const quantityInput = document.getElementById(`count_${productId}`);
//       const quantity = parseInt(quantityInput.value, 10);
//       const availableQuantity = parseInt(quantityInput.getAttribute("data-available-quantity"), 10);
//       const change = 1;
//       fetch("/updateQuantity", {
//         method: "POST",
//         headers: {
//           "Content-Type": "application/json",
//         },
//         body: JSON.stringify({ productId, change }),
//       });
//       // Check if quantity exceeds available quantity
//       if (quantity >= availableQuantity) {
//         // Display "Out of Stock" message
//         const outOfStockMessage = document.querySelector(`#outOfStockMessage_${productId}`);
//         if (outOfStockMessage) {
//           outOfStockMessage.style.display = "block";
//         }

//         // Prevent further increase
//         return;
//       }
//       updateQuantity(productId, 1);
//     });
//   });

//   updateTotalAmount();
// }); -->











// document.addEventListener("DOMContentLoaded", () => {
//     const increaseButtons = document.querySelectorAll(".increase-quantity");
//     const decreaseButtons = document.querySelectorAll(".decrease-quantity");
//     // Function to update the total price
//     function updateTotalAmount() {
//       let totalAmount = 0;

//       // Get all product rows
//       const productRows = document.querySelectorAll(".row.gy-3.mb-4");
//       productRows.forEach((row) => {
//         const productId = row
//           .querySelector(".decrease-quantity")
//           .getAttribute("data-product-id");
//         const quantityInput = row.querySelector(`#count_${productId}`);
//         const productAmount = parseFloat(
//           row.querySelector(`#productAmount_${productId}`).textContent
//         );

//         totalAmount += productAmount;
//       });






//       // Update the total amount in the HTML
//       const totalAmountCell = document.getElementById("totalAmountCell");
//       totalAmountCell.value = totalAmount.toFixed(2);

//       // If you want to display it in a specific format in the HTML:
//       const subTotal = document.getElementById("sub-total");
//       subTotal.textContent = `Rs ${totalAmount.toFixed(2)}`;

//     }

//     updateTotalAmount();


//     increaseButtons.forEach((button) => {
//       button.addEventListener("click", () => {
//         const productId = button.getAttribute("data-product-id");
//         const quantityInput = document.getElementById(`count_${productId}`);
//         const quantity = parseInt(quantityInput.value, 10);
//         const availableQuantity = parseInt(
//           quantityInput.getAttribute("data-available-quantity"),
//           10
//         );

//         const outOfStockMessage = document.querySelector(
//           `#outOfStockMessage_${productId}`
//         );
//         if (quantity >= availableQuantity) {
//           // Display "Out of Stock" message if needed
//           outOfStockMessage.style.display = "block";
//           return;
//         }

//         // Make an AJAX request to update the quantity
//         updateQuantity(productId, 1);
//       });
//     });

//     decreaseButtons.forEach((button) => {
//       button.addEventListener("click", () => {
//         const productId = button.getAttribute("data-product-id");
//         const quantityInput = document.getElementById(`count_${productId}`);
//         const quantity = parseInt(quantityInput.value, 10);
//         const outOfStockMessage = document.querySelector(
//           `#outOfStockMessage_${productId}`
//         );
//         if (quantity <= 1) {
//           // Prevent further decrease when quantity is 1
//           return;
//         }
//         outOfStockMessage.style.display = "none";
//         // Make an AJAX request to update the quantity
//         updateQuantity(productId, -1);


//       });
//     });

//     // Function to send AJAX request to update quantity
//     async function updateQuantity(productId, change) {
//       try {
//         const response = await fetch("/updateQuantity", {
//           method: "POST",
//           headers: {
//             "Content-Type": "application/json",
//           },
//           body: JSON.stringify({ productId, change }),
//         });

//         if (response.ok) {
//           const data = await response.json();
//           // Update the quantity and product amount on success
//           const quantityInput = document.getElementById(`count_${productId}`);
//           const productAmount = document.getElementById(`productAmount_${productId}`);
//           const existingValue = productAmount.getAttribute("data-value");

//           if (quantityInput) {
//             quantityInput.value = data.newQuantity;
//             productAmount.textContent = existingValue * data.newQuantity;

//             // You may also update the total amount
//             updateTotalAmount();
//           }

//         }
//         else if (response.status === 400) {
//           const data = await response.json();
//           alert(data.error); // Display the "Product is currently out of sto
//         }
//         else {
//           console.error("Error updating quantity:", response.statusText);
//         }
//       } catch (error) {
//         console.error("Error updating quantity:", error);
//       }
//     }



//   });








const postCheckout = async(req,res)=>{
    const userId = req.session.userId
    const user = await User.findById(userId);
    if (user && user.status === 'Blocked') {
      console.log("kernninda");
      req.flash('error', 'Your account is blocked. You cannot make purchases.');
      return res.redirect('/homepage'); // Redirect to a suitable page.
    }
    else{
    console.log(req.body);
    const PaymentMethod = req.body.paymentMethod
    const Address = req.body.Address
    const amount = req.session.totalPrice;
    const Email = user.email
    const cart = await Cart.findOne({UserId:userId}).populate("Items.ProductId")
    console.log(req.session.totalPrice);
    
    const address = await User.findOne(
      {
        _id: userId,
      },
      {
        Address: {
          $elemMatch: { _id: new mongoose.Types.ObjectId(Address) },
        },
      }
    );
    console.log("add====", address);
  
    const add = {
      Name: address.Address[0].Name,
      Address: address.Address[0].AddressLane,
      Pincode: address.Address[0].Pincode,
      City: address.Address[0].City,
      State: address.Address[0].State,
      Mobile: address.Address[0].Mobile,
    };
  
  
    const newOrders = new Order({
     UserId: userId,
     Items: cart.Items,
     OrderDate: moment(new Date()).format('llll') ,
     ExpectedDeliveryDate : moment().add(4, 'days').format('llll'),
     TotalPrice: req.session.totalPrice,
     Address: Address,
     PaymentMethod: PaymentMethod
    })
    //delete the items in the cart after checkout  
    await  Cart.findByIdAndDelete(cart._id)
    //save order to database
    const order = await  newOrders.save();
    console.log(order,"in orders");
    req.session.orderId = order._id
  
    for (const item of order.Items) {
     const productId = item.ProductId;
     const quantity = item.Quantity;
   
     const product = await Product.findById(productId);
   
     if (product) {
       const updatedQuantity = product.stock - quantity;
   
       if (updatedQuantity <=0) {
         product.stock = 0;
     product.Status = "Out of Stock";
     await product.save();
       } else {
         // Update the product's available quantity
         product.stock = updatedQuantity;
   
         // Save the updated product back to the database
         await product.save();
       }
     }
   }
  //  cod
   if(PaymentMethod === "cod"){
    //send email with details of orders
    const transporter = nodemailer.createTransport({
     port: 465,
     host: "smtp.gmail.com",
     auth: {
       user: "techboompage@gmail.com",
       pass: process.env.PASSWORD,
     },
     secure: true,
   });
   const mailData = {
     from: "techboompage@gmail.com",
     to: Email,
     subject:'Your Orders!' ,
     text:`Hello! ${user.username} Your order has been received and will be processed within one business day.`+
     ` your total price is ${req.session.totalPrice}`
   };
   transporter.sendMail(mailData, (error, info) => {
     if (error) {
       return console.log(error);
     }
     console.log("Success");
   });
   res.json({ codSuccess: true });
  }
  
  else if(PaymentMethod === 'online') {
  
    console.log("hereeeeeee");
    const order = {
      amount: amount,
      currency: "INR",
      receipt: req.session.orderId,
    };
    await razorpay
      .createRazorpayOrder(order)
      .then((createdOrder) => {
        console.log("payment response", createdOrder);
        res.json({ createdOrder, order });
      })
      .catch((err) => {
        console.log(err);
      });
  
    
      
    
  }
  else if(PaymentMethod === "wallet"){
    const transporter = nodemailer.createTransport({
      port: 465,
      host: "smtp.gmail.com",
      auth: {
        user: "techboompage@gmail.com",
        pass: process.env.PASSWORD,
      },
      secure: true,
    });
    const mailData = {
      from: "techboompage@gmail.com",
      to: Email,
      subject: "Your Orders!",
      text:
        `Hello! ${user.Username} Your order has been received and will be processed within one business day.` +
        ` your total price is ${req.session.totalPrice}`,
    };
    transporter.sendMail(mailData, (error, info) => {
      if (error) {
        return console.log(error);
      }
      console.log("Success");
    });
    await User.findByIdAndUpdate(userId,{$inc:{WalletAmount: -order.TotalPrice}})
    await Order.findByIdAndUpdate(order._id,{PaymentStatus:'Paid'})
    await Cart.findByIdAndDelete(cart._id);
    res.json({ walletSuccess: true });
  }
  //  res.redirect('/orderSuccess')
  //   console.log(cart.Items);
  }
  
  }
  const verifyPayment= async (req, res) => {
    console.log("it is the body", req.body);
    let hmac = crypto.createHmac("sha256", process.env.KEY_SECRET);
    hmac.update(
      req.body.payment.razorpay_order_id +
        "|" +
        req.body.payment.razorpay_payment_id
    );
  
    hmac = hmac.digest("hex");
    if (hmac === req.body.payment.razorpay_signature) {
      const orderId = new mongoose.Types.ObjectId(
        req.body.order.createdOrder.receipt
      );
      const updateOrderDocument = await Order.findByIdAndUpdate(orderId, {
        PaymentStatus: "Paid",
        PaymentMethod: "Online",
      });
      res.json({ success: true });
    } else {
      console.log("hmac failed");
      res.json({ failure: true });
    }
  };
  



  const name = document.getElementById('Name').value; // Replace 'Name' with the actual ID of your name input
  const image = document.getElementById('Image').value; // Replace 'Image' with the actual ID of your image input

  if (!name || !image) {
    alert('Both Name and Image are required for category update.');
    return false; // Prevent form submission
  }

  return true; // Allow form submission if validation passes
}
const errorBox = document.querySelector('.error-message');
      const successBox = document.querySelector('.success-message');
  
      if ("<%= error %>") {
        errorBox.style.display = 'block';
      }
  
      if ("<%= success %>") {
        successBox.style.display = 'block';
      }














